# -*- coding: utf-8 -*-
"""Week_2_Agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qw3IXlwC4mUcGcM1arbY5M59ey3MllA2
"""

#Requirements to be installed
!pip install anthropic>=0.24.0 pydantic>=2.6.1 python-dotenv>=1.0.1 requests>=2.32.0 -q
!pip install gradio reportlab

#E Importing everythign needed in the notebook throught
import os, json, asyncio, requests
from pydantic import BaseModel, Field
from dotenv import load_dotenv
from anthropic import Anthropic
from typing import Any, Dict, List
import gradio as gr
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet
import tempfile
from datetime import datetime

#getting Api keys
load_dotenv()

from google.colab import userdata
API_KEY=userdata.get('ANTHROPIC_API_KEYS')

#Helper(using anthripic)
try:
    _HAS_ANTHROPIC = True
except Exception:
    _HAS_ANTHROPIC = False

#chose 'claude-opus-4-20250514' model from anthropic.
def call_anthropic(prompt: str, model="claude-opus-4-20250514", temperature=0.0, max_tokens=1000):
    """Call Anthropic either via SDK or fallback HTTP."""
    if _HAS_ANTHROPIC:
        client = Anthropic(api_key=API_KEY)
        resp = client.messages.create(
            model=model,
            max_tokens=max_tokens,
            temperature=temperature,
            messages=[
                {"role": "user", "content": prompt}
            ],
        )
        return resp.content[0].text
    else:
        url = "https://api.anthropic.com/v1/messages"
        headers = {"x-api-key": API_KEY, "content-type": "application/json"}
        data = {
            "model": model,
            "max_tokens": max_tokens,
            "temperature": temperature,
            "messages": [{"role": "user", "content": prompt}],
        }
        r = requests.post(url, headers=headers, json=data)
        r.raise_for_status()
        return r.json()["content"][0]["text"]

#creating the ClarifierAgent
class ClarifierOutput(BaseModel):
    questions: List[str]
    refined_query: str

class ClarifierAgent:
    def __init__(self, model="claude-opus-4-20250514", n_questions=3):
        self.model = model
        self.n = n_questions

    async def run(self, user_query: str) -> ClarifierOutput:
        prompt = f"""
You are a Clarifier agent. Given a user's research query, produce *only valid JSON* in this format:

{{
  "questions": ["question1", "question2", "question3"],
  "refined_query": "refined query"
}}

User query:
\"\"\"{user_query}\"\"\"
"""
        raw = await asyncio.to_thread(call_anthropic, prompt, self.model)
        try:
            data = json.loads(raw)
        except Exception:
            start, end = raw.find("{"), raw.rfind("}") + 1
            data = json.loads(raw[start:end])
        return ClarifierOutput(**data)

#Now the Researchc Agent
class KeyFinding(BaseModel):
    title: str
    detail: str

class ResearcherOutput(BaseModel):
    short_summary: str
    key_findings: List[KeyFinding]
    suggested_sources: List[str]

class ResearcherAgent:
    def __init__(self, model="claude-opus-4-20250514"):
        self.model = model

    async def run(self, clarified_query: str) -> ResearcherOutput:
        prompt = f"""
You are a Research Agent. Conduct virtual research and return JSON only.

Clarified query:
\"\"\"{clarified_query}\"\"\"

JSON format:
{{
  "short_summary": "...",
  "key_findings": [
    {{"title": "Finding 1", "detail": "Details"}},
    {{"title": "Finding 2", "detail": "Details"}}
  ],
  "suggested_sources": ["Source 1", "Source 2"]
}}
"""
        raw = await asyncio.to_thread(call_anthropic, prompt, self.model)
        try:
            parsed = json.loads(raw)
        except Exception:
            start, end = raw.find("{"), raw.rfind("}") + 1
            parsed = json.loads(raw[start:end])

        key_findings = [KeyFinding(**kf) for kf in parsed.get("key_findings", [])]
        return ResearcherOutput(
            short_summary=parsed.get("short_summary", ""),
            key_findings=key_findings,
            suggested_sources=parsed.get("suggested_sources", []),
        )

#EvaluatorAgent
class EvaluationOutput(BaseModel):
    clarity: str
    accuracy: str
    completeness: str
    strengths: List[str]
    weaknesses: List[str]
    recommendations: List[str]

class EvaluatorAgent:
    def __init__(self, model="claude-opus-4-20250514"):
        self.model = model

    async def run(self, summary: str, findings: List[KeyFinding], refined_query: str) -> EvaluationOutput:
        findings_text = "\n".join([f"- {f.title}: {f.detail}" for f in findings])
        prompt = f"""
You are an expert evaluator. Evaluate the research summary based on these findings.
Return JSON only in this format:
{{
  "clarity": "...",
  "accuracy": "...",
  "completeness": "...",
  "strengths": ["..."],
  "weaknesses": ["..."],
  "recommendations": ["..."]
}}

Findings:
{findings_text}

Summary:
{summary}

Refined Query: {refined_query}
"""
        raw = await asyncio.to_thread(call_anthropic, prompt, self.model)
        try:
            parsed = json.loads(raw)
        except Exception:
            start, end = raw.find("{"), raw.rfind("}") + 1
            parsed = json.loads(raw[start:end])
        return EvaluationOutput(**parsed)

#ReseearchManager
class ResearchManager:
    def __init__(self):
        self.clarifier = ClarifierAgent()
        self.researcher = ResearcherAgent()
        self.evaluator = EvaluatorAgent()

    async def run(self, query: str) -> dict:
        print("\n Clarifying query...")
        clar = await self.clarifier.run(query)
        print("Clarifying Questions:", clar.questions)
        print("Refined Query:", clar.refined_query)

        print("\n Conducting research...")
        research = await self.researcher.run(clar.refined_query)
        print("Summary:", research.short_summary)

        print("\n Evaluating results...")
        evaluation = await self.evaluator.run(research.short_summary, research.key_findings, clar.refined_query)

        report = {
            "original_query": query,
            "clarifying_questions": clar.questions,
            "refined_query": clar.refined_query,
            "research_summary": research.short_summary,
            "key_findings": [f.dict() for f in research.key_findings],
            "evaluation": evaluation.dict(),
        }
        return report

#A demo for the exercise
async def main():
    query = input("Enter your research query: ")
    manager = ResearchManager()
    result = await manager.run(query)

    print("\n\n===== FINAL RESEARCH REPORT =====")
    print(json.dumps(result, indent=2))

await main()

# === Correct main_workflow matching your agent implementations ===
async def main_workflow(user_query: str) -> Dict[str, Any]:
    """
    Orchestrate ClarifierAgent -> ResearcherAgent -> EvaluatorAgent.
    Returns a plain dict suitable for JSON/PDF output.
    """
    try:
        # instantiate agents (use same constructor args you used elsewhere)
        clarifier = ClarifierAgent()
        researcher = ResearcherAgent()
        evaluator = EvaluatorAgent()

        # 1) Clarify (ClarifierAgent.run is async and returns a Pydantic model)
        clarifier_out = await clarifier.run(user_query)
        # clarifier_out has .questions (list[str]) and .refined_query (str)

        refined_query = clarifier_out.refined_query

        # 2) Research (ResearcherAgent.run is async and returns a Pydantic model)
        researcher_out = await researcher.run(refined_query)
        # researcher_out has .short_summary, .key_findings (Pydantic list), .suggested_sources

        # 3) Evaluate (EvaluatorAgent.run is async and returns a Pydantic model)
        evaluation_out = await evaluator.run(
            summary=researcher_out.short_summary,
            findings=researcher_out.key_findings,
            refined_query=refined_query
        )

        # 4) Build plain dict (use model_dump for Pydantic v2)
        result = {
            "original_query": user_query,
            "clarifying_questions": clarifier_out.questions if hasattr(clarifier_out, "questions") else clarifier_out.model_dump().get("questions"),
            "refined_query": refined_query,
            "research_summary": researcher_out.short_summary,
            "key_findings": [kf.model_dump() if hasattr(kf, "model_dump") else kf for kf in researcher_out.key_findings],
            "suggested_sources": researcher_out.suggested_sources if hasattr(researcher_out, "suggested_sources") else researcher_out.model_dump().get("suggested_sources", []),
            "evaluation": evaluation_out.model_dump() if hasattr(evaluation_out, "model_dump") else evaluation_out
        }
        return result

    except Exception as e:
        # Return an error-shaped dict so UI can show it cleanly
        return {
            "original_query": user_query,
            "error": True,
            "error_message": str(e)
        }

# a PDF builder from the results
def generate_pdf(report_dict, filename_prefix="report"):
    # Clean filename to get the report name
    safe_prefix = "_".join(filename_prefix.lower().split())[:50]
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"deep_research_report_{safe_prefix}_{timestamp}.pdf"

    tmp_file_path = os.path.join(tempfile.gettempdir(), filename)
    doc = SimpleDocTemplate(tmp_file_path, pagesize=A4)
    styles = getSampleStyleSheet()
    elements = []

    #better formatting of the pdf
    def add_section(title, content):
        elements.append(Paragraph(f"<b>{title}</b>", styles["Heading3"]))
        elements.append(Spacer(1, 8))
        elements.append(Paragraph(content.replace("\n", "<br/>"), styles["Normal"]))
        elements.append(Spacer(1, 12))

    elements.append(Paragraph("<b>Deep Research Report</b>", styles["Title"]))
    elements.append(Spacer(1, 12))

    add_section("Original Query", report_dict.get("original_query", ""))
    add_section("Refined Query", report_dict.get("refined_query", ""))
    add_section("Clarifying Questions", "\n".join(report_dict.get("clarifying_questions", [])))
    add_section("Research Summary", report_dict.get("research_summary", ""))

    findings = report_dict.get("key_findings", [])
    findings_text = "\n".join([f"- {f.get('title','')}: {f.get('detail','')}" for f in findings])
    add_section("Key Findings", findings_text)

    #include the evaluations in te report
    evaluation = report_dict.get("evaluation", {})
    eval_text = "\n".join([
        f"Clarity: {evaluation.get('clarity','')}",
        f"Accuracy: {evaluation.get('accuracy','')}",
        f"Completeness: {evaluation.get('completeness','')}",
        "\nStrengths:\n" + "\n".join(evaluation.get("strengths", [])),
        "\nWeaknesses:\n" + "\n".join(evaluation.get("weaknesses", [])),
        "\nRecommendations:\n" + "\n".join(evaluation.get("recommendations", []))
    ])
    add_section("Evaluation", eval_text)

    doc.build(elements)
    return tmp_file_path

# -How to handle the workfloe
async def process_query(user_query):
    """Run workflow and prepare outputs."""
    result = await main_workflow(user_query)

    if result.get("error"):
        return None, None, "An error occurred while generating the report."

    # dynamixally naminng our file
    filename_prefix = result.get("refined_query", user_query).replace(" ", "_").lower()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

    # Generate  the PDF
    pdf_path = generate_pdf(result, filename_prefix=filename_prefix)

    # Generate JSON
    json_filename = f"deep_research_data_{filename_prefix}_{timestamp}.json"
    json_path = os.path.join(tempfile.gettempdir(), json_filename)
    with open(json_path, "w") as f:
        json.dump(result, f, indent=2)

    return pdf_path, json_path, "Report generated successfully."

# The interface (Gradio)
with gr.Blocks(theme=gr.themes.Soft(primary_hue="indigo")) as demo:
    # app Header
    with gr.Row():
        gr.Markdown(
            """
            <h1 style='text-align:center; font-weight:700;'>
                AI Research Report Generator
            </h1>
            <p style='text-align:center; font-size:16px; color:gray;'>
                Enter your research topic or question to automatically generate a structured research report with clarifications, analysis, and evaluation.
            </p>
            """,
            elem_id="header"
        )

    # Input field
    query_input = gr.Textbox(
        label="Research Topic or Question",
        placeholder="e.g., Secrets of becoming an AI expert in 2025",
        lines=3
    )

    # Generate button
    generate_btn = gr.Button("Generate Report", variant="primary")

    # Output area (only download links)
    with gr.Row():
        pdf_output = gr.File(label="Download PDF Report", interactive=False)
        json_output = gr.File(label="Download JSON Data", interactive=False)

    # Status message
    status_msg = gr.Markdown("", elem_id="status_text")

    # Click action
    def on_generate_click(q):
        pdf_path, json_path, msg = asyncio.run(process_query(q))
        if pdf_path and json_path:
            return pdf_path, json_path, f"<p style='color:green;'>{msg}</p>", gr.update(interactive=True), gr.update(interactive=True)
        else:
            return None, None, f"<p style='color:red;'>{msg}</p>", gr.update(interactive=False), gr.update(interactive=False)

    generate_btn.click(
        fn=on_generate_click,
        inputs=query_input,
        outputs=[pdf_output, json_output, status_msg, pdf_output, json_output]
    )

demo.launch()